\documentclass{article}
\usepackage[yyyymmdd]{datetime}
\usepackage[shortlabels]{enumitem}
\usepackage[nottoc]{tocbibind}
\usepackage{url}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{graphicx}
\graphicspath{{./images}}


\pgfplotsset{width=10cm,compat=1.9}
\usepgfplotslibrary{external}
\definecolor{pearl}{RGB}{234,224,220}
\definecolor{bg-se}{RGB}{246, 246, 246}
\usepackage{listings}

\definecolor{clr-background}{RGB}{255,255,255}
\definecolor{clr-text}{RGB}{0,0,0}
\definecolor{clr-string}{RGB}{163,21,21}
\definecolor{clr-namespace}{RGB}{0,0,0}
\definecolor{clr-preprocessor}{RGB}{128,128,128}
\definecolor{clr-keyword}{RGB}{0,0,255}
\definecolor{clr-type}{RGB}{43,145,175}
\definecolor{clr-variable}{RGB}{0,0,0}
\definecolor{clr-constant}{RGB}{111,0,138} % macro color
\definecolor{clr-comment}{RGB}{0,128,0}

\lstdefinestyle{VS2017}{
	backgroundcolor=\color{white},
	basicstyle=\color{clr-text}, % any text
	stringstyle=\color{clr-string},
	identifierstyle=\color{clr-variable}, % just about anything that isn't a directive, comment, string or known type
	commentstyle=\color{clr-comment},
	directivestyle=\color{clr-preprocessor}, % preprocessor commands
	% listings doesn't differentiate between types and keywords (e.g. int vs return)
	breakatwhitespace=false,         
	breaklines=true, 
	% use the user types color
	keywordstyle=\color{clr-type},
	keywordstyle={[2]\color{clr-constant}}, % you'll need to define these or use a custom language
	tabsize=2
}

% Make header with name and date etc.
\usepackage{fancyhdr}
\lhead{Pedro D. Llerenas\\M\'etodos Numericos I}
\rhead{\today\\Tarea I}
\thispagestyle{fancy}

\usepackage[utf8]{inputenc}
\setlength{\parindent}{0pt} % Don't indent new paragraphs
\setlength{\headheight}{24pt} 

\newcommand{\Z}{{\mathbb Z}}
\newcommand{\N}{\mathbb N}
\newcommand{\Q}{\mathbb Q}
\newcommand{\R}{\mathbb R}
\newcommand{\C}{\mathbb C}

\begin{document}

\begin{enumerate}
	\item Como es bien sabido, la representaci\'on num\'erica binaria de tipo signo/exponente/mantisa, depende de la creatividad o precisi\'on que desee el programador. Analicemos qu\'e sucede con un sistema de numeraci\'on binario a $n>0$ (entero) bits, para esto elige un valor par entre 10 y 20, crea el sistema de numeraci\'on entero similar al estudiado en clase, (la mantisa debe ser, al menos, la mitad del n\'umero elegido). Describe tu sistema de numeraci\'on, ¿Cu\'al es el menor y mayor de los n\'umeros representados? Presenta un n\'umero que no se pueda representar en tu sistema seleccionado. Describe tu proceso. (4 pts) NOTA: punto extra si adem\'as se describe un sistema fraccionario que tenga sentido.
	      \begin{mdframed}[
			      linecolor=darkgray,
			      backgroundcolor=white]
		      \begin{proof}[\textbf{Demostraci\'on.}]
			      Usaremos 16 bits en total. 1 para el signo, 3 para el exponente, 12 para la mantisa. Esto nos genera n\'umeros en el rango
			      \[ [-1*2^7*(2^{12} - 1), 2^7*(2^{12} - 1)] = [-524160, 524160] \]

			      Un n\'umero que no podemos representar es el $ 2^{12} + 1 $, debido a que no es un m\'ultiplo de dos y es mayor a $ 2^{12} - 1 $, el mayor numero que podemos representar con la mantisa.
			      \lstinputlisting[caption=Generaci\'on de n\'umeros posibles con el sistema elegido. Fraccionario y entero., language=C, style=VS2017]{p1.c}


			      El c\'odigo anterior genera dos archivos csv, uno con todos los valores (positivos) posibles de la representaci\'on elegida, y otro con los valores fraccionarios, que describimos m\'as adelante. En la siguiente tabla, presentamos algunos valores enteros representables por nuestro sistema. El encabezado de la columna representa el exponente que multiplica la mantisa.

			      \begin{center}
				      \begin{tabular}{c|cccccccc}
					      \textbf{binary} & $2^{0}$ & $2^{1}$ & $2^{2}$ & $2^{3}$ & $2^{4}$ & $2^{5}$ & $2^{6}$ & $2^{7}$ \\ \hline
					      000000000001    & 1       & 2       & 4       & 8       & 16      & 32      & 64      & 128     \\
					      000000000010    & 2       & 4       & 8       & 16      & 32      & 64      & 128     & 256     \\
					      000000000011    & 3       & 6       & 12      & 24      & 48      & 96      & 192     & 384     \\
					      000000000100    & 4       & 8       & 16      & 32      & 64      & 128     & 256     & 512     \\
					      000000000101    & 5       & 10      & 20      & 40      & 80      & 160     & 320     & 640     \\
					      000000000110    & 6       & 12      & 24      & 48      & 96      & 192     & 384     & 768     \\
					      000000000111    & 7       & 14      & 28      & 56      & 112     & 224     & 448     & 896     \\
					      000000001000    & 8       & 16      & 32      & 64      & 128     & 256     & 512     & 1024    \\
					      \vdots          & \vdots  & \vdots  & \vdots  & \vdots  & \vdots  & \vdots  & \vdots  & \vdots  \\
					      111111111111    & 4095    & 8190    & 16380   & 32760   & 65520   & 131040  & 262080  & 524160
				      \end{tabular}
			      \end{center}
			      Para el sistema fraccionario, definimos el bit implicito como
			      $$
				      \begin{cases}
					      \texttt{b}_{imp}= 1   & \texttt{if } 0 <\texttt{exp} < 7                           \\
					      \texttt{b}_{imp} =  0 & \texttt{if } \texttt{exp} = 0 \texttt{ and matissa} \neq 0
				      \end{cases}
			      $$
			      y
			      $$
				      \begin{cases}
					      \texttt{exp}=\texttt{exp}-3 & \text{if } 0 <\texttt{exp} < 7, \\
					      \texttt{exp} = -2           & \text{if } \texttt{exp} = 0,
				      \end{cases}
			      $$
			      y finalmente, cuando $ \texttt{exp} = 7 $,
			      $$
				      \begin{cases}
					      \pm \infty   & \text{if } \texttt{mantissa } = 0,    \\
					      \texttt{NaN} & \text{if } \texttt{mantissa } \neq 0.
				      \end{cases}
			      $$
			      De esta manera, obtenemos los valores (truncados para una mejor presentaci\'on)
			      \begin{center}
				      \resizebox{\textwidth}{!}{
					      \begin{tabular}{c|ccccccc}
						      \textbf{binary} & $2^{-2}$ & $2^{-2}$ & $2^{-1}$ & $2^{0}$  & $2^{1}$  & $2^{2}$  & $2^{3}$   \\ \hline
						      000000000001    & 0.000061 & 0.250061 & 0.500122 & 1.000244 & 2.000488 & 4.000977 & 8.001953  \\
						      000000000010    & 0.000122 & 0.250122 & 0.500244 & 1.000488 & 2.000977 & 4.001953 & 8.003906  \\
						      000000000011    & 0.000183 & 0.250183 & 0.500366 & 1.000732 & 2.001465 & 4.002930 & 8.005859  \\
						      000000000100    & 0.000244 & 0.250244 & 0.500488 & 1.000977 & 2.001953 & 4.003906 & 8.007812  \\
						      000000000101    & 0.000305 & 0.250305 & 0.500610 & 1.001221 & 2.002441 & 4.004883 & 8.009766  \\
						      000000000110    & 0.000366 & 0.250366 & 0.500732 & 1.001465 & 2.002930 & 4.005859 & 8.011719  \\
						      000000000111    & 0.000427 & 0.250427 & 0.500854 & 1.001709 & 2.003418 & 4.006836 & 8.013672  \\
						      \vdots          & \vdots   & \vdots   & \vdots   & \vdots   & \vdots   & \vdots   & \vdots    \\
						      111111111111    & 0.249939 & 0.499939 & 0.999878 & 1.999756 & 3.999512 & 7.999023 & 15.998047 \\
					      \end{tabular}
				      }
			      \end{center}
			      De manera an\'aloga, podemos obtener los valores negativos. Entonces, el n\'umero m\'aximo (finito) de la representaci\'on fraccionaria es
			      \[
				      2^3 \displaystyle\sum_{i = 1}^{6} 2^{-i} = 15.998046875
			      \]
			      mientras que el m\'inimos es el negativo del m\'aximo. El m\'as cercano a 0 es $ \pm2^{-12} = 0.000244140625 $.
		      \end{proof}
	      \end{mdframed}

	\item Consideremos la siguiente sucesi\'on $\{x_n\}_{n\in \N} \subset \R$ definida de manera recurrente como: (4 pts)
	      \begin{align*}
		      x_2     & =2,                                               \\
		      x_{n+1} & = 2^{n-\frac{1}{2}}\sqrt{1-\sqrt{1-4^{1-n}x^2_n}}
	      \end{align*}
	      \begin{enumerate}
		      \item Escribe un programa para encontrar los primeros $n$ t\'erminos de la sucesi\'on.
		      \item Aplica tu programa para encontrar los t\'erminos de la sucesi\'on cuando $$n = 6, 7, 8, 9, 10,12, 18, 20$$, ¿a qu\'e valor tiende la sucesi\'on? (\'esta sucesi\'on tiende a un valor distinto de cero).
		      \item Encuentra los t\'erminos 50 y 100, ¿qu\'e sucede con la sucesi\'on? Grafica los t\'erminos de la sucesi\'on desde 2 hasta 100. Explica detalladamente el por qu\'e del comportamiento que tiene la computadora al calcular estos t\'erminos.
	      \end{enumerate}
	      \begin{mdframed}[
			      linecolor=darkgray,
		      ]
		      \begin{proof}[\textbf{Demostraci\'on.}]
			      Primero mostraremos que utilizar directamente la secuencia resulta en los t\'erminos divergiendo a infinito debido a los errores de precisi\'on de punto flotante.
			      Podemos notar que la secuencia puede ser reescrita de tal manera que la cantidad de restas se puede reducir a 1.
			      \begin{align*}
				      x_{n+1} & = 2^{n-1/2} \sqrt{1-\sqrt{1-4^{1-n}x^2_n}}                                                                            \\
				              & = 2^{n-1/2} \sqrt{1-\sqrt{1-4^{1-n}x^2_n}} \cdot\frac{\sqrt{1-\sqrt{1+4^{1-n}x^2_n}}}{\sqrt{1+\sqrt{1-4^{1-n}x^2_n}}} \\
				              & = 2^{n-1/2}\frac{\sqrt{1-(1-4^{1-n}x^2_n)}}{\sqrt{1-\sqrt{1+4^{1-n}x^2_n}}}                                           \\
				              & = 2^{n-1/2} \frac{2^{1-n}x_n}{\sqrt{1-\sqrt{1+4^{1-n}x^2_n}}}                                                         \\
				              & = \frac{\sqrt{2}x_n}{\sqrt{1-\sqrt{1+4^{1-n}x^2_n}}}.
			      \end{align*}
			      \lstinputlisting[caption=Calcular secuencia de n\'umeros que se acerca a $\pi$, language=C, style=VS2017]{p2.c}

			      \begin{figure}[H]
				      \caption{Secuencia usando algoritmo ingenuo}
				      \includegraphics[width=\textwidth]{naive_pi_approx}
			      \end{figure}

			      \begin{figure}[H]
				      \caption{Secuencia usando algoritmo reduciendo restas}
				      \includegraphics[width=\textwidth]{pi_approx}
			      \end{figure}
			      En el algoritmo ingenuo,
			      \begin{align*}
				      x_5= 3.1214451524539055          \\
				      x_6= 3.1365484908043393          \\
				      x_7= 3.1403311572738355          \\
				      x_8= 3.1412772513118705          \\
				      x_9= 3.1415138015831676          \\
				      x_{10}= 3.1415729408653790       \\
				      x_{11}= 3.1415877258399871       \\
				      x_{12}= 3.1415914221202459       \\
				      x_{13}= 3.1415923462637427       \\
				      x_{14}= 3.1415925771976707       \\
				      x_{15}= 3.1415926358946096       \\
				      x_{16}= 3.1415926548673574       \\
				      x_{17}= 3.1415926833264782       \\
				      x_{18}= 3.1415927592174677       \\
				      x_{19}= 3.1415929109994405       \\
				      x_{20}= 3.1415941252549588       \\
				      x_{50}= 4194304.0000797957181931 \\
				      x_{100} = 4722366482959487205376
			      \end{align*}
			      mientras que en el otro, tenemos
			      \begin{align*}
				      x_5= 3.1214451524539042     \\
				      x_6= 3.1365484908043384     \\
				      x_7= 3.1403311572738337     \\
				      x_8= 3.1412772513119043     \\
				      x_9= 3.1415138015832844     \\
				      x_{10}= 3.1415729408658670  \\
				      x_{11}= 3.1415877258357106  \\
				      x_{12}= 3.1415914221295211  \\
				      x_{13}= 3.1415923462482072  \\
				      x_{14}= 3.1415925773227302  \\
				      x_{15}= 3.1415926351361882  \\
				      x_{16}= 3.1415926496343785  \\
				      x_{17}= 3.1415926533037521  \\
				      x_{18}= 3.1415926542659216  \\
				      x_{19}= 3.1415926545512902  \\
				      x_{20}= 3.1415926546674577  \\
				      x_{50} = 3.1415926564792924 \\
				      x_{100} = 3.1415926594676811
			      \end{align*}


			      Como podemos observar, el segundo algoritmo (que reduce el numero de restas), se mantiene cerca de $\pi$, mientras que el ingenuo explota y diverge a infinito debido a las aproximaciones que se deben hacer con las restas de punto flotante.
		      \end{proof}
	      \end{mdframed}


	\item Al n\'umero representable inmediatamente despu\'es de la unidad se le conoce como el epsil\'on de la computadora
	      machine el cual nos permite calcular el n\'umero real representable inmediatamente posterior; \'esto se obtiene
	      al multiplicar el epsil\'on por el real y sumarlo a ese real. Utilizando el siguiente algoritmo, crea un c\'odigo
	      que calcule el machine de tu computadora, s\'olo hace falta indicar el tipo de variable que es "epsilon" (float o
	      doble). El \'ultimo valor impreso corresponde al epsilon de la computadora. (2 pts)
	      \begin{mdframed}[
			      linecolor=darkgray,
			      backgroundcolor=white]
		      \begin{proof}[\textbf{Demostraci\'on.}]
			      La lista impresa es
			      \begin{center}

				      1.0000000000000000000000\\
				      0.5000000000000000000000\\
				      0.2500000000000000000000\\
				      0.1250000000000000000000\\
				      0.0625000000000000000000\\
				      0.0312500000000000000000\\
				      0.0156250000000000000000\\
				      0.0078125000000000000000\\
				      0.0039062500000000000000\\
				      0.0019531250000000000000\\
				      0.0009765625000000000000\\
				      0.0004882812500000000000\\
				      0.0002441406250000000000\\
				      0.0001220703125000000000\\
				      0.0000610351562500000000\\
				      0.0000305175781250000000\\
				      0.0000152587890625000000\\
				      0.0000076293945312500000\\
				      0.0000038146972656250000\\
				      0.0000019073486328125000\\
				      0.0000009536743164062500\\
				      0.0000004768371582031250\\
				      0.0000002384185791015625\\
				      0.0000001192092895507812\\
				      0.0000000596046447753906\\
				      0.0000000298023223876953\\
				      0.0000000149011611938477\\
				      0.0000000074505805969238\\
				      0.0000000037252902984619\\
				      0.0000000018626451492310\\
				      0.0000000009313225746155\\
				      0.0000000004656612873077\\
				      0.0000000002328306436539\\
				      0.0000000001164153218269\\
				      0.0000000000582076609135\\
				      0.0000000000291038304567\\
				      0.0000000000145519152284\\
				      0.0000000000072759576142\\
				      0.0000000000036379788071\\
				      0.0000000000018189894035\\
				      0.0000000000009094947018\\
				      0.0000000000004547473509\\
				      0.0000000000002273736754\\
				      0.0000000000001136868377\\
				      0.0000000000000568434189\\
				      0.0000000000000284217094\\
				      0.0000000000000142108547\\
				      0.0000000000000071054274\\
				      0.0000000000000035527137\\
				      0.0000000000000017763568\\
				      0.0000000000000008881784\\
				      0.0000000000000004440892\\
				      0.0000000000000002220446\\

			      \end{center}

			      Despu\'es de 52 iteraciones, obtenemos que $$\epsilon = 0.0000000000000002220446 = 2.22046\times10^{-16} \approx 2^{-52}$$.
			      \lstinputlisting[caption=Calcular epsilon de la m\'aquina, language=C, style=VS2017]{p3.c}
		      \end{proof}
	      \end{mdframed}

\end{enumerate}

\end{document}
